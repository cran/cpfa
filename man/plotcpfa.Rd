\name{plotcpfa}
\alias{plotcpfa}
\title{
Plot Optimal Model from Classification with Parallel Factor Analysis
}
\description{
Plots optimal model based on results from a 'wrapcpfa' object generated by 
function \code{cpfa}. 
}
\usage{
plotcpfa(object, cmeasure = "acc", meanvalue = TRUE, supNum = FALSE, 
         parallel = FALSE, cl = NULL, scale.remode = NULL, newscales = 1, 
         scale.abmode = NULL, sign.remode = NULL, newsigns = 1, 
         sign.abmode = NULL, ...)
}
\arguments{
\item{object}{
  An object of class 'wrapcpfa' from function \code{cpfa}.
}
\item{cmeasure}{
  Classification performance measure used to select the optimal number of 
  components. Options include \code{c("err", "acc", "tpr", "fpr", "tnr", "fnr", 
  "ppv", "npv", "fdr", "fom", "fs")}. If \code{cmeasure} is in \code{c("err", 
  "fpr", "fnr", "fdr", "fom")}, the number of components that minimized 
  \code{cmeasure} is selected among all classification methods. Otherwise, the 
  number that maximized \code{cmeasure} is selected.
}
\item{meanvalue}{
  Logical indicating whether to find the optimal number of components based on 
  the mean performance across replications from the results generated by 
  \code{cpfa}. If \code{meanvalue = FALSE}, the median is used. 
}
\item{supNum}{
  Logical indicating whether to suppress text displaying component weight values 
  within plot cells. If TRUE, values are not displayed.
}
\item{parallel}{
  Logical indicating whether parallel computing should be used. If TRUE, 
  parallel computing is used.
}
\item{cl}{
  Cluster for parallel computing, which is used when \code{parallel = TRUE}. 
  Note that if \code{parallel = TRUE} and \code{cl = NULL}, then the cluster 
  is defined as \code{makeCluster(detectCores())}.
}
\item{scale.remode}{
  Character that indicates a mode to rescale. Must be one of \code{c("A", "B", 
  "C", "D")}. Sent directly to argument \code{mode} in function \code{rescale} 
  from package \bold{multiway}. See help file for \code{rescale} for additional 
  details.
}
\item{newscales}{
  The root mean-square for columns of the mode indicated by \code{scale.remode}. 
  See help file for \code{rescale} for additional details.
}
\item{scale.abmode}{
  Character that indicates the mode that absorbs the inverse of rescalings 
  applied to the mode indicated by \code{scale.remode}. Must be one of 
  \code{c("A", "B", "C", "D")}. Sent directly to argument \code{absorb} in 
  function \code{rescale} from package \bold{multiway}. See help file for 
  \code{rescale} for additional details.
}
\item{sign.remode}{
  Character that indicates a mode to resign. Must be one of \code{c("A", "B", 
  "C", "D")}. Sent directly to argument \code{mode} in function \code{resign} 
  from package \bold{multiway}. See help file for \code{resign} for additional 
  details.
}
\item{newsigns}{
  Scalar or vector indicating resignings for columns of the mode indicated by 
  \code{sign.remode}. See help file for \code{resign} for additional details.
}
\item{sign.abmode}{
  Character that indicates the mode that absorbs the negation of the resignings 
  applied to the mode indicated by \code{sign.remode}. Must be one of 
  \code{c("A", "B", "C", "D")}. Sent directly to argument \code{absorb} in 
  function \code{resign} from package \bold{multiway}. See help file for 
  \code{resign} for additional details.
}
\item{...}{
  Additional arguments to be passed to function \code{parafac} for fitting a 
  Parafac model or function \code{parafac2} for fitting a Parafac2 model. See 
  help file for function \code{parafac} or for function \code{parafac2} for 
  additional details.
}
}
\details{
Selects the number of components that optimized a performance measure across 
all classification methods used by \code{cpfa}. With this optimal number of 
components, fits the Parafac or Parafac2 model that was used by \code{cpfa} to 
create the input 'wrapcpfa' object. Uses same constraints used in \code{cpfa}. 
Plots component weights for this optimal model using heatmaps. Darker red 
indicates component weights that are more negative while darker green indicates 
component weights that are more positive. For three-way Parafac, plots A and B 
weights. For four-way Parafac, plots A, B, and C weights. For three-way 
Parafac2, plots B weights. For four-way Parafac2, plots B and C weights.
}
\value{
Returns one or more heatmap plots of component weights for the optimal Parafac 
or Parafac2 model. Returns list of estimated component weights from the optimal
model.
}
\author{
 Matthew Asisgress <mattgress@protonmail.ch>
}
\references{
See help file for function \code{cpfa} for a list of references.
}
\examples{
########## Parafac2 example with 4-way array and multiclass response ##########
\dontrun{
# set seed and simulate a four-way ragged array related to a multiclass response
set.seed(5)
cormat <- matrix(c(1, .35, .35, .35, 1, .35, .35, .35, 1), nrow = 3, ncol = 3)
data <- simcpfa(arraydim = c(10, 11, 12, 100), model = "parafac2", nfac = 3, 
                nclass = 3, nreps = 1e2, onreps = 10, corresp = rep(.75, 3), 
                meanpred = rep(2, 3), modes = 4, corrpred = cormat)

# initialize
alpha <- seq(0, 1, length = 2)
gamma <- c(0, 1)
cost <- c(0.1, 5)
rda.alpha <- seq(0.1, 0.9, length = 2)
delta <- c(0.1, 2)
method <- c("PLR", "SVM", "RDA")
family <- "multinomial"
parameters <- list(alpha = alpha, gamma = gamma, cost = cost, 
                   rda.alpha = rda.alpha, delta = delta)
model <- "parafac2"
nfolds <- 3
nstart <- 3

# constrain first mode weights to be orthogonal, fourth mode to be nonnegative
const <- c("orthog", "uncons", "uncons", "nonneg")

# fit Parafac2 model and use fourth mode weights to tune classification
# methods, to predict class labels, and to return classification 
# performance measures pooled across multiple train-test splits
output <- cpfa(x = data$X, y = as.factor(data$y), model = model, nfac = 3, 
               nrep = 2, ratio = 0.8, nfolds = nfolds, method = method, 
               family = family, parameters = parameters, 
               type.out = "descriptives", seeds = NULL, plot.out = TRUE, 
               parallel = FALSE, const = const, nstart = nstart, ctol = 1e-2)

# plot heatmap of component weights for optimal model
plotcpfa(output, nstart = nstart, ctol = 1e-3)
}
}